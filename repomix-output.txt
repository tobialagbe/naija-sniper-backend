This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-15T23:42:17.309Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  auth/
    dto/
      forgot-password.dto.ts
      login.dto.ts
      reset-password.dto.ts
    guards/
      jwt-auth.guard.ts
    strategies/
      jwt.strategy.ts
    auth.controller.ts
    auth.module.ts
    auth.service.ts
  bounty/
    dto/
      create-bounty-winner.dto.ts
      create-bounty.dto.ts
      update-bounty.dto.ts
    entities/
      bounty-winner.entity.ts
      bounty.entity.ts
    bounty.controller.ts
    bounty.module.ts
    bounty.service.ts
  paystack/
    dto/
      initialize-transaction.dto.ts
      verify-transaction.dto.ts
    interfaces/
      paystack.interfaces.ts
    paystack.controller.ts
    paystack.module.ts
    paystack.service.spec.ts
    paystack.service.ts
    README.md
  perks/
    data/
      perks.ts
    dto/
      create-user-perk.dto.ts
      update-user-perk.dto.ts
    entities/
      user-perk.entity.ts
    perks.controller.ts
    perks.module.ts
    perks.service.ts
  seeders/
    bounty.seeder.ts
    leaderboard.seeder.ts
    main.ts
    seed.command.ts
    seeder.module.ts
    seeder.service.ts
    tournament.seeder.ts
    user-perk.seeder.ts
    user.seeder.ts
  tournament/
    dto/
      create-tournament.dto.ts
      get-leaderboard.dto.ts
      record-score.dto.ts
      update-tournament.dto.ts
    entities/
      leaderboard.entity.ts
      tournament.entity.ts
    tournament.controller.ts
    tournament.module.ts
    tournament.service.ts
  user/
    dto/
      create-user.dto.ts
      update-user.dto.ts
    entities/
      user.entity.ts
    user.controller.ts
    user.module.ts
    user.service.ts
  app.controller.spec.ts
  app.controller.ts
  app.service.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.eslintignore
.eslintrc.js
.gitignore
.prettierignore
.prettierrc
nest-cli.json
package.json
README.md
tsconfig.build.json
tsconfig.json

================================================================
Files
================================================================

================
File: src/auth/dto/forgot-password.dto.ts
================
import { IsEmail, IsNotEmpty } from 'class-validator';

export class ForgotPasswordDto {
  @IsNotEmpty()
  @IsEmail()
  readonly email: string;
}

================
File: src/auth/dto/login.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @IsNotEmpty()
  @IsString()
  readonly usernameOrEmail: string;

  @IsNotEmpty()
  @IsString()
  readonly password: string;
}

================
File: src/auth/dto/reset-password.dto.ts
================
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class ResetPasswordDto {
  @IsNotEmpty()
  @IsString()
  readonly token: string;

  @IsNotEmpty()
  @IsString()
  @MinLength(6)
  readonly password: string;
}

================
File: src/auth/guards/jwt-auth.guard.ts
================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

================
File: src/auth/strategies/jwt.strategy.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UserService } from '../../user/user.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    private readonly userService: UserService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    const user = await this.userService.findOne(payload.sub);
    if (!user) {
      throw new UnauthorizedException('User not found');
    }
    return user;
  }
}

================
File: src/auth/auth.controller.ts
================
import { Body, Controller, Post } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { ForgotPasswordDto } from './dto/forgot-password.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { CreateUserDto } from '../user/dto/create-user.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  register(@Body() createUserDto: CreateUserDto) {
    return this.authService.register(createUserDto);
  }

  @Post('login')
  login(@Body() loginDto: LoginDto) {
    // console.log(loginDto);
    return this.authService.login(loginDto);
  }

  @Post('forgot-password')
  forgotPassword(@Body() forgotPasswordDto: ForgotPasswordDto) {
    return this.authService.forgotPassword(forgotPasswordDto);
  }

  @Post('reset-password')
  resetPassword(@Body() resetPasswordDto: ResetPasswordDto) {
    return this.authService.resetPassword(resetPasswordDto);
  }
}

================
File: src/auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UserModule } from '../user/user.module';
import { JwtStrategy } from './strategies/jwt.strategy';

@Module({
  imports: [
    UserModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN'),
        },
      }),
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}

================
File: src/auth/auth.service.ts
================
import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';
import { LoginDto } from './dto/login.dto';
import { ForgotPasswordDto } from './dto/forgot-password.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { CreateUserDto } from '../user/dto/create-user.dto';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
  ) {}

  async register(createUserDto: CreateUserDto) {
    const user = await this.userService.create(createUserDto);
    return this.generateToken(user);
  }

  async login(loginDto: LoginDto) {
    const { usernameOrEmail, password } = loginDto;

    // Check if user exists by username or email
    let user;
    try {
      // First try to find by email
      if (usernameOrEmail.includes('@')) {
        user = await this.userService.findByEmail(usernameOrEmail);
      } else {
        // Then try to find by username
        user = await this.userService.findByUsername(usernameOrEmail);
      }
    } catch (error) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Validate password
    const isPasswordValid = await user.validatePassword(password);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    return this.generateToken(user);
  }

  async forgotPassword(forgotPasswordDto: ForgotPasswordDto) {
    const { email } = forgotPasswordDto;
    const resetToken = await this.userService.createPasswordResetToken(email);

    // Here you would typically send an email with the reset token
    // For simplicity, we'll just return the token
    return {
      message: 'Password reset token has been sent to your email',
      resetToken,
    };
  }

  async resetPassword(resetPasswordDto: ResetPasswordDto) {
    const { token, password } = resetPasswordDto;
    await this.userService.resetPassword(token, password);
    return { message: 'Password has been reset successfully' };
  }

  private generateToken(user: any) {
    const payload = {
      sub: user._id,
      username: user.username,
      email: user.email,
    };

    return {
      accessToken: this.jwtService.sign(payload),
      user,
    };
  }
}

================
File: src/bounty/dto/create-bounty-winner.dto.ts
================
import { IsNotEmpty, IsNumber, IsOptional, IsString, Min } from 'class-validator';

export class CreateBountyWinnerDto {
  @IsNotEmpty()
  @IsString()
  readonly bountyId: string;

  @IsNotEmpty()
  @IsString()
  readonly userId: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
  readonly killCount?: number;
}

================
File: src/bounty/dto/create-bounty.dto.ts
================
import { IsBoolean, IsDate, IsNotEmpty, IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class CreateBountyDto {
  @IsOptional()
  @IsString()
  readonly imageUrl?: string;

  @IsNotEmpty()
  @IsString()
  readonly name: string;

  @IsOptional()
  @IsString()
  readonly description?: string;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  readonly amount: number;

  @IsNotEmpty()
  @IsNumber()
  @Min(1)
  readonly numberOfWinners: number;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  readonly startDate: Date;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  readonly endDate: Date;

  @IsOptional()
  @IsNumber()
  @Min(0)
  readonly killCount?: number;

  @IsOptional()
  @IsBoolean()
  readonly active?: boolean;
}

================
File: src/bounty/dto/update-bounty.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreateBountyDto } from './create-bounty.dto';

export class UpdateBountyDto extends PartialType(CreateBountyDto) {}

================
File: src/bounty/entities/bounty-winner.entity.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { Bounty } from './bounty.entity';

export type BountyWinnerDocument = BountyWinner & Document;

@Schema({ timestamps: true })
export class BountyWinner {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'Bounty', required: true })
  bountyId: Bounty;

  @Prop({ required: true })
  bountyName: string;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: string;

  @Prop({ required: true })
  username: string;

  @Prop({ default: 0 })
  killCount: number;
}

export const BountyWinnerSchema = SchemaFactory.createForClass(BountyWinner);

================
File: src/bounty/entities/bounty.entity.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type BountyDocument = Bounty & Document;

@Schema({ timestamps: true })
export class Bounty {
  @Prop()
  imageUrl?: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ required: true })
  amount: number;

  @Prop({ required: true })
  numberOfWinners: number;

  @Prop({ required: true })
  startDate: Date;

  @Prop({ required: true })
  endDate: Date;

  @Prop({ default: 0 })
  killCount: number;

  @Prop({ default: true })
  active: boolean;
}

export const BountySchema = SchemaFactory.createForClass(Bounty);

================
File: src/bounty/bounty.controller.ts
================
import { Controller, Get, Post, Body, Param, Delete, Put, UseGuards } from '@nestjs/common';
import { BountyService } from './bounty.service';
import { CreateBountyDto } from './dto/create-bounty.dto';
import { UpdateBountyDto } from './dto/update-bounty.dto';
import { CreateBountyWinnerDto } from './dto/create-bounty-winner.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('bounties')
export class BountyController {
  constructor(private readonly bountyService: BountyService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  create(@Body() createBountyDto: CreateBountyDto) {
    return this.bountyService.create(createBountyDto);
  }

  @Get()
  findAll() {
    return this.bountyService.findAll();
  }

  @Get('active')
  findActive() {
    return this.bountyService.findActiveBounties();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.bountyService.findOne(id);
  }

  @UseGuards(JwtAuthGuard)
  @Put(':id')
  update(@Param('id') id: string, @Body() updateBountyDto: UpdateBountyDto) {
    return this.bountyService.update(id, updateBountyDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.bountyService.remove(id);
  }

  // @UseGuards(JwtAuthGuard)
  @Post('winners')
  createBountyWinner(@Body() createBountyWinnerDto: CreateBountyWinnerDto) {
    return this.bountyService.createBountyWinner(createBountyWinnerDto);
  }

  @Get('winners/:bountyId')
  findAllBountyWinners(@Param('bountyId') bountyId: string) {
    return this.bountyService.findAllBountyWinners(bountyId);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('winners/:id')
  removeBountyWinner(@Param('id') id: string) {
    return this.bountyService.removeBountyWinner(id);
  }
}

================
File: src/bounty/bounty.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BountyService } from './bounty.service';
import { BountyController } from './bounty.controller';
import { Bounty, BountySchema } from './entities/bounty.entity';
import { BountyWinner, BountyWinnerSchema } from './entities/bounty-winner.entity';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Bounty.name, schema: BountySchema },
      { name: BountyWinner.name, schema: BountyWinnerSchema },
    ]),
    UserModule,
  ],
  controllers: [BountyController],
  providers: [BountyService],
  exports: [BountyService],
})
export class BountyModule {}

================
File: src/bounty/bounty.service.ts
================
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateBountyDto } from './dto/create-bounty.dto';
import { UpdateBountyDto } from './dto/update-bounty.dto';
import { Bounty, BountyDocument } from './entities/bounty.entity';
import { BountyWinner, BountyWinnerDocument } from './entities/bounty-winner.entity';
import { CreateBountyWinnerDto } from './dto/create-bounty-winner.dto';
import { UserService } from '../user/user.service';

@Injectable()
export class BountyService {
  constructor(
    @InjectModel(Bounty.name) private bountyModel: Model<BountyDocument>,
    @InjectModel(BountyWinner.name) private bountyWinnerModel: Model<BountyWinnerDocument>,
    private readonly userService: UserService,
  ) {}

  async create(createBountyDto: CreateBountyDto): Promise<Bounty> {
    const createdBounty = new this.bountyModel(createBountyDto);
    return createdBounty.save();
  }

  async findAll(): Promise<Bounty[]> {
    return this.bountyModel.find().exec();
  }

  async findOne(id: string): Promise<{ bounty: Bounty; winnersReached: boolean }> {
    const bounty = await this.bountyModel.findById(id).exec();
    if (!bounty) {
      throw new NotFoundException(`Bounty with ID ${id} not found`);
    }
    
    // Count current winners
    const winnersCount = await this.bountyWinnerModel.countDocuments({ bountyId: id }).exec();
    
    // Check if number of winners has been reached
    const winnersReached = winnersCount >= bounty.numberOfWinners;
    
    return { bounty, winnersReached };
  }

  async update(id: string, updateBountyDto: UpdateBountyDto): Promise<Bounty> {
    const bounty = await this.bountyModel
      .findByIdAndUpdate(id, updateBountyDto, { new: true })
      .exec();
    
    if (!bounty) {
      throw new NotFoundException(`Bounty with ID ${id} not found`);
    }
    
    return bounty;
  }

  async remove(id: string): Promise<Bounty> {
    const bounty = await this.bountyModel.findByIdAndDelete(id).exec();
    if (!bounty) {
      throw new NotFoundException(`Bounty with ID ${id} not found`);
    }
    return bounty;
  }

  async createBountyWinner(createBountyWinnerDto: CreateBountyWinnerDto): Promise<{ message: string; winner?: BountyWinner }> {
    const { bountyId, userId, killCount = 0 } = createBountyWinnerDto;
    
    // Check if bounty exists
    const bounty = await this.bountyModel.findById(bountyId).exec();
    if (!bounty) {
      throw new NotFoundException(`Bounty with ID ${bountyId} not found`);
    }
    
    // Check if user exists
    const user = await this.userService.findOne(userId);
    
    // Check if this user is already a winner for this bounty
    const existingWinner = await this.bountyWinnerModel.findOne({
      bountyId,
      userId,
    }).exec();
    
    if (existingWinner) {
      return { message: 'User is already a winner for this bounty' };
    }
    
    // Count current winners
    const winnersCount = await this.bountyWinnerModel.countDocuments({ bountyId }).exec();
    
    // Check if number of winners has been reached
    if (winnersCount >= bounty.numberOfWinners) {
      return { message: 'Maximum number of winners has been reached for this bounty' };
    }
    
    // Check if the killCount requirement is met
    if (bounty.killCount > 0 && killCount < bounty.killCount) {
      return { message: `Kill count does not meet the requirement of ${bounty.killCount}` };
    }
    
    // Create a new bounty winner entry
    const bountyWinner = new this.bountyWinnerModel({
      bountyId,
      bountyName: bounty.name,
      userId,
      username: user.username,
      killCount,
    });
    
    const savedWinner = await bountyWinner.save();
    return { 
      message: `Congratulations! You've successfully claimed the bounty!`, 
      winner: savedWinner 
    };
  }

  async findAllBountyWinners(bountyId: string): Promise<BountyWinner[]> {
    // Check if bounty exists
    const bounty = await this.bountyModel.findById(bountyId).exec();
    if (!bounty) {
      throw new NotFoundException(`Bounty with ID ${bountyId} not found`);
    }
    
    return this.bountyWinnerModel.find({ bountyId }).exec();
  }

  async removeBountyWinner(id: string): Promise<BountyWinner> {
    const bountyWinner = await this.bountyWinnerModel.findByIdAndDelete(id).exec();
    if (!bountyWinner) {
      throw new NotFoundException(`Bounty winner with ID ${id} not found`);
    }
    return bountyWinner;
  }

  async findActiveBounties(): Promise<{ hasActive: boolean; bounty?: Bounty }> {
    const activeBounties = await this.bountyModel.find({ active: true }).exec();
    if (activeBounties.length === 0) {
      return { hasActive: false };
    }
    return { hasActive: true, bounty: activeBounties[0] };
  }
}

================
File: src/paystack/dto/initialize-transaction.dto.ts
================
import { IsEmail, IsNotEmpty, IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class InitializeTransactionDto {
  @IsNotEmpty()
  @IsEmail()
  readonly email: string;

  @IsNotEmpty()
  @IsNumber()
  @Min(1)
  @Type(() => Number)
  readonly amount: number;

  @IsOptional()
  @IsString()
  readonly reference?: string;

  @IsOptional()
  @IsString()
  readonly callback_url?: string;

  @IsOptional()
  readonly metadata?: any;
}

================
File: src/paystack/dto/verify-transaction.dto.ts
================
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyTransactionDto {
  @IsNotEmpty()
  @IsString()
  readonly reference: string;
}

================
File: src/paystack/interfaces/paystack.interfaces.ts
================
// Request interfaces
export interface InitializeTransactionDto {
  email: string;
  amount: number;
  reference?: string;
  callback_url?: string;
  plan?: string;
  invoice_limit?: number;
  metadata?: any;
  channels?: string[];
  split_code?: string;
  subaccount?: string;
  transaction_charge?: number;
  bearer?: string;
}

// Response interfaces
export interface PaystackBaseResponse<T> {
  status: boolean;
  message: string;
  data: T;
}

export interface InitializeTransactionResponse {
  authorization_url: string;
  access_code: string;
  reference: string;
}

export interface VerifyTransactionResponse {
  id: number;
  domain: string;
  status: string;
  reference: string;
  amount: number;
  message: string;
  gateway_response: string;
  paid_at: string;
  created_at: string;
  channel: string;
  currency: string;
  ip_address: string;
  metadata: any;
  log: any;
  fees: number;
  fees_split?: any;
  customer: {
    id: number;
    first_name: string;
    last_name: string;
    email: string;
    customer_code: string;
    phone: string;
    metadata: any;
    risk_action: string;
  };
  authorization: {
    authorization_code: string;
    bin: string;
    last4: string;
    exp_month: string;
    exp_year: string;
    channel: string;
    card_type: string;
    bank: string;
    country_code: string;
    brand: string;
    reusable: boolean;
    signature: string;
    account_name: string;
  };
  plan: any;
}

================
File: src/paystack/paystack.controller.ts
================
import { Controller, Post, Body, Get, Param, HttpStatus, HttpException, UseGuards, Headers, Req } from '@nestjs/common';
import { PaystackService } from './paystack.service';
import { InitializeTransactionDto } from './dto/initialize-transaction.dto';
import { VerifyTransactionDto } from './dto/verify-transaction.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { Request } from 'express';

// Extend the Express Request interface to include rawBody
interface RequestWithRawBody extends Request {
  rawBody: Buffer;
}

@Controller('payments')
export class PaystackController {
  constructor(private readonly paystackService: PaystackService) {}

  /**
   * Initialize a transaction
   * @param initializeTransactionDto - The transaction data
   * @returns Transaction initialization response
   */
  
  @UseGuards(JwtAuthGuard)
  @Post('initialize')
  async initializeTransaction(@Body() initializeTransactionDto: InitializeTransactionDto) {
    try {
      return await this.paystackService.initializeTransaction(initializeTransactionDto);
    } catch (error) {
      throw new HttpException(
        error.response?.data?.message || 'Error initializing transaction',
        error.response?.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Verify a transaction
   * @param reference - The transaction reference to verify
   * @returns Transaction verification response
   */
  @Get('verify/:reference')
  async verifyTransaction(@Param('reference') reference: string) {
    try {
      return await this.paystackService.verifyTransaction(reference);
    } catch (error) {
      throw new HttpException(
        error.response?.data?.message || 'Error verifying transaction',
        error.response?.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Webhook endpoint for Paystack notifications
   * @param signature - The Paystack signature from headers
   * @param body - The webhook payload
   * @param request - Express request object with raw body
   * @returns Webhook acknowledgment
   */
  @Post('webhook')
  async handleWebhook(
    @Headers('x-paystack-signature') signature: string,
    @Body() body: any,
    @Req() request: RequestWithRawBody
  ) {
    // Always return a 200 response immediately to acknowledge receipt
    // Paystack expects a quick response
    
    // Verify the signature if provided
    if (signature) {
      // Get the raw body for signature verification
      const rawBody = request.rawBody;
      if (!rawBody) {
        console.warn('Raw body not available for webhook signature verification');
      } else {
        const isValid = this.paystackService.verifyWebhookSignature(
          signature,
          rawBody.toString()
        );
        
        if (!isValid) {
          console.warn('Invalid Paystack webhook signature');
          return { status: 'success' }; // Still return success to avoid retries
        }
      }
    }
    
    try {
      // Process the webhook event based on the event type
      const event = body.event;
      console.log(`Processing Paystack webhook: ${event}`);
      
      // Handle different event types
      switch (event) {
        case 'charge.success':
          // Handle successful payment
          console.log(`Payment successful for reference: ${body.data?.reference}`);
          break;
          
        case 'transfer.success':
          // Handle successful transfer
          break;
          
        default:
          console.log(`Unhandled webhook event type: ${event}`);
      }
      
      return { status: 'success' };
    } catch (error) {
      console.error('Error processing webhook:', error);
      return { status: 'success' }; // Still return success to avoid retries
    }
  }
}

================
File: src/paystack/paystack.module.ts
================
import { Module } from '@nestjs/common';
import { HttpModule } from '@nestjs/axios';
import { ConfigModule } from '@nestjs/config';
import { PaystackService } from './paystack.service';
import { PaystackController } from './paystack.controller';

@Module({
  imports: [
    HttpModule,
    ConfigModule,
  ],
  controllers: [PaystackController],
  providers: [PaystackService],
  exports: [PaystackService],
})
export class PaystackModule {}

================
File: src/paystack/paystack.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { PaystackService } from './paystack.service';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { of } from 'rxjs';
import { InitializeTransactionDto } from './dto/initialize-transaction.dto';

describe('PaystackService', () => {
  let service: PaystackService;
  let httpService: HttpService;
  
  const mockHttpService = {
    post: jest.fn(),
    get: jest.fn(),
  };
  
  const mockConfigService = {
    get: jest.fn().mockReturnValue('mock_secret_key'),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PaystackService,
        { provide: HttpService, useValue: mockHttpService },
        { provide: ConfigService, useValue: mockConfigService },
      ],
    }).compile();

    service = module.get<PaystackService>(PaystackService);
    httpService = module.get<HttpService>(HttpService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('initializeTransaction', () => {
    it('should initialize a transaction successfully', async () => {
      const initDto: InitializeTransactionDto = {
        email: 'test@example.com',
        amount: 1000,
        callback_url: 'https://example.com/callback'
      };
      
      const mockResponse = {
        status: true,
        message: 'Authorization URL created',
        data: {
          authorization_url: 'https://checkout.paystack.com/mock-url',
          access_code: 'mock-access-code',
          reference: 'mock-reference'
        }
      };
      
      mockHttpService.post.mockReturnValueOnce(
        of({
          data: mockResponse,
          status: 200,
          statusText: 'OK',
          headers: {},
          config: { headers: {} },
        })
      );

      const result = await service.initializeTransaction(initDto);
      
      expect(httpService.post).toHaveBeenCalledWith(
        'https://api.paystack.co/transaction/initialize',
        expect.objectContaining({
          email: initDto.email,
          amount: expect.any(Number),
          callback_url: initDto.callback_url,
        }),
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: 'Bearer mock_secret_key',
          }),
        })
      );
      
      expect(result).toEqual(mockResponse);
    });
  });

  describe('verifyTransaction', () => {
    it('should verify a transaction successfully', async () => {
      const reference = 'test-reference';
      
      const mockResponse = {
        status: true,
        message: 'Verification successful',
        data: {
          id: 12345,
          status: 'success',
          reference,
          amount: 1000,
          customer: {
            email: 'test@example.com'
          }
        }
      };
      
      mockHttpService.get.mockReturnValueOnce(
        of({
          data: mockResponse,
          status: 200,
          statusText: 'OK',
          headers: {},
          config: { headers: {} },
        })
      );

      const result = await service.verifyTransaction(reference);
      
      expect(httpService.get).toHaveBeenCalledWith(
        `https://api.paystack.co/transaction/verify/${reference}`,
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: 'Bearer mock_secret_key',
          }),
        })
      );
      
      expect(result).toEqual(mockResponse);
    });
  });
});

================
File: src/paystack/paystack.service.ts
================
import { Injectable, HttpException } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { firstValueFrom } from 'rxjs';
import { createHmac } from 'crypto';
import { 
  InitializeTransactionDto, 
  PaystackBaseResponse,
  InitializeTransactionResponse,
  VerifyTransactionResponse
} from './interfaces/paystack.interfaces';

@Injectable()
export class PaystackService {
  private readonly baseUrl: string;
  private readonly secretKey: string;

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
  ) {
    this.baseUrl = 'https://api.paystack.co';
    this.secretKey = this.configService.get<string>('PAYSTACK_SECRET_KEY');
    
    if (!this.secretKey) {
      console.warn('PAYSTACK_SECRET_KEY not found in environment variables. Paystack integration may not work correctly.');
    }
  }

  private getRequestHeaders() {
    return {
      Authorization: `Bearer ${this.secretKey}`,
      'Content-Type': 'application/json',
      'Cache-Control': 'no-cache',
    };
  }

  /**
   * Initialize a new transaction
   * @param initializeTransactionDto - Data for initializing transaction
   * @returns Promise containing transaction initialization data
   */
  async initializeTransaction(
    initializeTransactionDto: InitializeTransactionDto,
  ): Promise<PaystackBaseResponse<InitializeTransactionResponse>> {
    try {
      // Convert amount to lowest currency unit (kobo/cents)
      // Paystack expects amount in the subunit of the supported currency
      const amount = Math.round(initializeTransactionDto.amount * 100);
      
      const { data } = await firstValueFrom(
        this.httpService.post<PaystackBaseResponse<InitializeTransactionResponse>>(
          `${this.baseUrl}/transaction/initialize`,
          { ...initializeTransactionDto, amount },
          { headers: this.getRequestHeaders() }
        )
      );

      return data;
    } catch (error) {
      console.error('Paystack Initialize Transaction Error:', error.response?.data || error.message);
      throw new HttpException(
        error.response?.data?.message || 'Failed to initialize transaction',
        error.response?.status || 500,
      );
    }
  }

  /**
   * Verify a transaction's status
   * @param reference - The transaction reference to verify
   * @returns Promise containing transaction verification data
   */
  async verifyTransaction(
    reference: string,
  ): Promise<PaystackBaseResponse<VerifyTransactionResponse>> {
    try {
      const { data } = await firstValueFrom(
        this.httpService.get<PaystackBaseResponse<VerifyTransactionResponse>>(
          `${this.baseUrl}/transaction/verify/${reference}`,
          { headers: this.getRequestHeaders() }
        )
      );

      return data;
    } catch (error) {
      console.error('Paystack Verify Transaction Error:', error.response?.data || error.message);
      throw new HttpException(
        error.response?.data?.message || 'Failed to verify transaction',
        error.response?.status || 500,
      );
    }
  }

  /**
   * Verify the signature of a Paystack webhook
   * @param signature - The signature from the X-Paystack-Signature header
   * @param payload - The raw request body as a string
   * @returns boolean indicating if the signature is valid
   */
  verifyWebhookSignature(signature: string, payload: string): boolean {
    try {
      const hash = createHmac('sha512', this.secretKey)
        .update(payload)
        .digest('hex');
      
      return hash === signature;
    } catch (error) {
      console.error('Error verifying webhook signature:', error);
      return false;
    }
  }
}

================
File: src/paystack/README.md
================
# Paystack Payment Integration

This module provides integration with Paystack payment gateway, allowing you to:
1. Initialize transactions
2. Verify transaction status
3. Handle Paystack webhooks with signature verification

## Setup

1. Add your Paystack secret key to your environment variables:
```
PAYSTACK_SECRET_KEY=your_secret_key_here
```

2. Import the PaystackModule in your application:
```typescript
import { PaystackModule } from './paystack/paystack.module';

@Module({
  imports: [
    // ... other modules
    PaystackModule,
  ],
})
export class AppModule {}
```

## Available Endpoints

### Initialize Transaction

```
POST /payments/initialize
```

**Request Body:**
```json
{
  "email": "customer@example.com",
  "amount": 10.00, // Amount in your main currency unit (will be converted to subunits)
  "callback_url": "https://yourwebsite.com/payment-callback",
  "reference": "optional-unique-reference", // Optional
  "metadata": { // Optional
    "custom_field": "custom value"
  }
}
```

**Response:**
```json
{
  "status": true,
  "message": "Authorization URL created",
  "data": {
    "authorization_url": "https://checkout.paystack.com/abc123xyz",
    "access_code": "abc123xyz",
    "reference": "transaction-reference"
  }
}
```

### Verify Transaction

```
GET /payments/verify/:reference
```

**Response:**
```json
{
  "status": true,
  "message": "Verification successful",
  "data": {
    "id": 123456789,
    "status": "success",
    "reference": "transaction-reference",
    "amount": 1000, // Amount in kobo/cents
    "customer": {
      "email": "customer@example.com",
      // Other customer details
    },
    // Other transaction details
  }
}
```

### Webhook Endpoint

```
POST /payments/webhook
```

This endpoint handles Paystack event notifications. The module verifies the signature from the `x-paystack-signature` header to ensure the webhook is authentic. The webhook handler:

1. Verifies the signature using HMAC SHA-512
2. Processes different event types (e.g., charge.success, transfer.success)
3. Returns a 200 status code immediately as required by Paystack

To set up webhooks:
1. Log in to your Paystack dashboard
2. Go to Settings > API Keys & Webhooks
3. Add your webhook URL (e.g., `https://your-domain.com/api/payments/webhook`)
4. Save the webhook URL

## Using in Your Code

You can inject and use the PaystackService in your own services:

```typescript
import { Injectable } from '@nestjs/common';
import { PaystackService } from '../paystack/paystack.service';
import { InitializeTransactionDto } from '../paystack/dto/initialize-transaction.dto';

@Injectable()
export class YourService {
  constructor(private readonly paystackService: PaystackService) {}

  async processPayment(email: string, amount: number) {
    const transactionDto: InitializeTransactionDto = {
      email,
      amount,
      callback_url: 'https://yourwebsite.com/payment-callback'
    };

    // Initialize transaction
    const initResult = await this.paystackService.initializeTransaction(transactionDto);
    
    return initResult.data.authorization_url;
  }

  async verifyPayment(reference: string) {
    const verifyResult = await this.paystackService.verifyTransaction(reference);
    
    if (verifyResult.data.status === 'success') {
      // Payment successful, deliver value to customer
      return true;
    }
    
    return false;
  }
}
```

## Frontend Integration

To use Paystack in your frontend:

1. Initialize the transaction from your backend
2. Redirect user to the `authorization_url` or use the Paystack Popup library
3. After payment, user will be redirected to your callback URL
4. Verify the transaction status on your backend

## Important Notes

1. **Security**: Never expose your secret key on the frontend
2. **Amount**: Always verify the amount matches what you expect before delivering value
3. **Webhook**: Setup a webhook URL in your Paystack dashboard to receive real-time payment notifications
4. **Signature Verification**: The webhook endpoint verifies signatures to ensure requests are authentic

================
File: src/perks/data/perks.ts
================
export interface Perk {
  name: string;
  description: string;
  key: string; // 6 digit alphanumeric unique key
  imagePath: string;
}

export const PERKS: Perk[] = [
  {
    name: 'Extra Life',
    description: 'Gives player an extra life in tournament',
    key: 'EL1F3X',
    imagePath: '/assets/perks/extra-life.png',
  },
  {
    name: 'Double Points',
    description: 'Doubles points earned in a tournament match',
    key: 'DBLPTS',
    imagePath: '/assets/perks/double-points.png',
  },
  {
    name: 'Score Multiplier',
    description: 'Multiplies score by 1.5 for one game',
    key: 'SCR15X',
    imagePath: '/assets/perks/score-multiplier.png',
  },
  {
    name: 'Shield',
    description: 'Protects player from damage for 30 seconds',
    key: 'SHLD30',
    imagePath: '/assets/perks/shield.png',
  },
  {
    name: 'Weapon Upgrade',
    description: 'Upgrades weapon to next tier for one match',
    key: 'WPNUPG',
    imagePath: '/assets/perks/weapon-upgrade.png',
  },
  {
    name: 'Health Boost',
    description: 'Increases max health by 25% for one match',
    key: 'HLTH25',
    imagePath: '/assets/perks/health-boost.png',
  },
  {
    name: 'Free Entry',
    description: 'Free entry to any tournament',
    key: 'FRNTRY',
    imagePath: '/assets/perks/free-entry.png',
  },
];

// Utility function to get a perk by key
export function getPerkByKey(key: string): Perk | undefined {
  return PERKS.find(perk => perk.key === key);
}

================
File: src/perks/dto/create-user-perk.dto.ts
================
import { IsNotEmpty, IsNumber, IsOptional, IsString, Min } from 'class-validator';

export class CreateUserPerkDto {
  @IsNotEmpty()
  @IsString()
  readonly userId: string;

  @IsNotEmpty()
  @IsString()
  readonly perkKey: string;

  @IsOptional()
  @IsNumber()
  @Min(1)
  readonly count?: number;
}

================
File: src/perks/dto/update-user-perk.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserPerkDto } from './create-user-perk.dto';
import { IsBoolean, IsDate, IsNumber, IsOptional, Min } from 'class-validator';

export class UpdateUserPerkDto extends PartialType(CreateUserPerkDto) {
  @IsOptional()
  @IsNumber()
  @Min(0)
  readonly count?: number;

  @IsOptional()
  @IsBoolean()
  readonly used?: boolean;

  @IsOptional()
  @IsDate()
  readonly usedAt?: Date;
}

================
File: src/perks/entities/user-perk.entity.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';

export type UserPerkDocument = UserPerk & Document;

@Schema({ timestamps: true })
export class UserPerk {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: string;

  @Prop({ required: true })
  perkKey: string;

  @Prop({ required: true })
  perkName: string;

  @Prop({ required: true, default: 1 })
  count: number;

  @Prop({ default: false })
  used: boolean;

  @Prop()
  usedAt?: Date;
}

export const UserPerkSchema = SchemaFactory.createForClass(UserPerk);

================
File: src/perks/perks.controller.ts
================
import { Controller, Get, Post, Body, Param, Delete, Put, UseGuards } from '@nestjs/common';
import { PerksService } from './perks.service';
import { CreateUserPerkDto } from './dto/create-user-perk.dto';
import { UpdateUserPerkDto } from './dto/update-user-perk.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('perks')
export class PerksController {
  constructor(private readonly perksService: PerksService) {}

  // Get all available perks
  @Get()
  getAllPerks() {
    return this.perksService.getAllPerks();
  }

  // Get a specific perk by key
  @Get('types/:key')
  getPerkByKey(@Param('key') key: string) {
    return this.perksService.getPerkByKey(key);
  }

  // Create a user perk (requires authentication)
  @UseGuards(JwtAuthGuard)
  @Post('user')
  createUserPerk(@Body() createUserPerkDto: CreateUserPerkDto) {
    return this.perksService.createUserPerk(createUserPerkDto);
  }

  // Get all perks for a user
  @Get('user/:userId')
  getUserPerks(@Param('userId') userId: string) {
    return this.perksService.getUserPerks(userId);
  }

  // Get a specific user perk
  @Get('user/perk/:id')
  getUserPerk(@Param('id') id: string) {
    return this.perksService.getUserPerk(id);
  }

  // Update a user perk (requires authentication)
//   @UseGuards(JwtAuthGuard)
  @Put('user/perk/:id')
  updateUserPerk(
    @Param('id') id: string,
    @Body() updateUserPerkDto: UpdateUserPerkDto,
  ) {
    return this.perksService.updateUserPerk(id, updateUserPerkDto);
  }

  // Delete a user perk (requires authentication)
//   @UseGuards(JwtAuthGuard)
  @Delete('user/perk/:id')
  removeUserPerk(@Param('id') id: string) {
    return this.perksService.removeUserPerk(id);
  }

  // Use a perk (requires authentication)
//   @UseGuards(JwtAuthGuard)
  @Post('user/perk/:id/use')
  usePerk(@Param('id') id: string) {
    return this.perksService.usePerk(id);
  }
}

================
File: src/perks/perks.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PerksService } from './perks.service';
import { PerksController } from './perks.controller';
import { UserPerk, UserPerkSchema } from './entities/user-perk.entity';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: UserPerk.name, schema: UserPerkSchema },
    ]),
    UserModule,
  ],
  controllers: [PerksController],
  providers: [PerksService],
  exports: [PerksService],
})
export class PerksModule {}

================
File: src/perks/perks.service.ts
================
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserPerk, UserPerkDocument } from './entities/user-perk.entity';
import { CreateUserPerkDto } from './dto/create-user-perk.dto';
import { UpdateUserPerkDto } from './dto/update-user-perk.dto';
import { PERKS, getPerkByKey } from './data/perks';

@Injectable()
export class PerksService {
  constructor(
    @InjectModel(UserPerk.name) private userPerkModel: Model<UserPerkDocument>,
  ) {}

  // Get all available perks
  getAllPerks() {
    return PERKS;
  }

  // Get a specific perk by key
  getPerkByKey(key: string) {
    const perk = getPerkByKey(key);
    if (!perk) {
      throw new NotFoundException(`Perk with key ${key} not found`);
    }
    return perk;
  }

  // Create a user perk
  async createUserPerk(createUserPerkDto: CreateUserPerkDto): Promise<UserPerk> {
    const { userId, perkKey, count = 1 } = createUserPerkDto;

    // Check if perk exists
    const perk = getPerkByKey(perkKey);
    if (!perk) {
      throw new BadRequestException(`Perk with key ${perkKey} does not exist`);
    }

    // Check if user already has this perk
    const existingUserPerk = await this.userPerkModel.findOne({
      userId,
      perkKey,
    }).exec();

    if (existingUserPerk) {
      // Update count if user already has this perk
      existingUserPerk.count += count;
      return existingUserPerk.save();
    }

    // Create new user perk
    const userPerk = new this.userPerkModel({
      userId,
      perkKey,
      perkName: perk.name,
      count,
    });

    return userPerk.save();
  }

  // Get all perks for a user
  async getUserPerks(userId: string): Promise<UserPerk[]> {
    return this.userPerkModel.find({ userId }).exec();
  }

  // Get a specific user perk
  async getUserPerk(id: string): Promise<UserPerk> {
    const userPerk = await this.userPerkModel.findById(id).exec();
    if (!userPerk) {
      throw new NotFoundException(`User perk with ID ${id} not found`);
    }
    return userPerk;
  }

  // Update a user perk
  async updateUserPerk(id: string, updateUserPerkDto: UpdateUserPerkDto): Promise<UserPerk> {
    const userPerk = await this.userPerkModel
      .findByIdAndUpdate(id, updateUserPerkDto, { new: true })
      .exec();
    
    if (!userPerk) {
      throw new NotFoundException(`User perk with ID ${id} not found`);
    }
    
    return userPerk;
  }

  // Delete a user perk
  async removeUserPerk(id: string): Promise<UserPerk> {
    const userPerk = await this.userPerkModel.findByIdAndDelete(id).exec();
    if (!userPerk) {
      throw new NotFoundException(`User perk with ID ${id} not found`);
    }
    return userPerk;
  }

  // Use a perk
  async usePerk(id: string): Promise<UserPerk> {
    const userPerk = await this.userPerkModel.findById(id).exec();
    if (!userPerk) {
      throw new NotFoundException(`User perk with ID ${id} not found`);
    }

    if (userPerk.count <= 0) {
      throw new BadRequestException('No perks remaining to use');
    }

    userPerk.count -= 1;
    userPerk.used = true;
    userPerk.usedAt = new Date();

    return userPerk.save();
  }
}

================
File: src/seeders/bounty.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Bounty } from '../bounty/entities/bounty.entity';

@Injectable()
export class BountySeeder {
  constructor(
    @InjectModel(Bounty.name) private bountyModel: Model<Bounty>,
  ) {}

  async seed() {
    const bounties = [
      {
        name: 'Fortnite Victory Royale Bounty',
        description: 'Get a Victory Royale in Fortnite Battle Royale',
        reward: 50,
        amount: 50,
        numberOfWinners: 5,
        startDate: new Date('2024-04-15T00:00:00Z'),
        endDate: new Date('2024-04-22T23:59:59Z'),
        killCount: 10,
        game: 'Fortnite',
        platform: 'PC',
        active: true,
      },
      {
        name: 'Call of Duty Kill Streak Challenge',
        description: 'Achieve a 10-kill streak in Call of Duty: Warzone',
        reward: 75,
        amount: 75,
        numberOfWinners: 3,
        startDate: new Date('2024-04-20T00:00:00Z'),
        endDate: new Date('2024-04-27T23:59:59Z'),
        killCount: 10,
        game: 'Call of Duty: Warzone',
        platform: 'Cross-Platform',
        active: true,
      },
      {
        name: 'Valorant Ace Challenge',
        description: 'Get an Ace (5 kills in one round) in Valorant',
        reward: 100,
        amount: 100,
        numberOfWinners: 2,
        startDate: new Date('2024-04-25T00:00:00Z'),
        endDate: new Date('2024-05-02T23:59:59Z'),
        killCount: 5,
        game: 'Valorant',
        platform: 'PC',
        active: false,
      },
    ];

    // Clear existing bounties
    await this.bountyModel.deleteMany({});
    
    // Insert new bounties
    await this.bountyModel.insertMany(bounties);
    
    console.log('Bounty seeding completed');
  }
}

================
File: src/seeders/leaderboard.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Tournament } from '../tournament/entities/tournament.entity';
import { User } from '../user/entities/user.entity';
import { Leaderboard } from '../tournament/entities/leaderboard.entity';

@Injectable()
export class LeaderboardSeeder {
  constructor(
    @InjectModel(Tournament.name) private tournamentModel: Model<Tournament>,
    @InjectModel(User.name) private userModel: Model<User>,
    @InjectModel(Leaderboard.name) private leaderboardModel: Model<Leaderboard>,
  ) {}

  async seed() {
    // Get all tournaments
    const tournaments = await this.tournamentModel.find().exec();
    
    // Get all users
    const users = await this.userModel.find().exec();
    
    // Clear existing leaderboard entries
    await this.leaderboardModel.deleteMany({});
    
    const leaderboardEntries = [];
    
    // Generate leaderboard data for each tournament
    for (const tournament of tournaments) {
      // For each tournament, assign random scores to each user
      // We'll make sure that at least 3 users have entries for each tournament
      const shuffledUsers = [...users].sort(() => 0.5 - Math.random());
      const usersForThisTournament = shuffledUsers.slice(0, Math.min(5, users.length));
      
      for (const user of usersForThisTournament) {
        // Generate a random score between 100 and 1000
        const score = Math.floor(Math.random() * 900) + 100;
        
        leaderboardEntries.push({
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          tournamentId: tournament._id,
          tournamentName: tournament.name,
          score: score,
          userId: user._id,
        });
      }
    }
    
    // Insert all leaderboard entries
    if (leaderboardEntries.length > 0) {
      await this.leaderboardModel.insertMany(leaderboardEntries);
    }
    
    console.log(`Leaderboard seeding completed: ${leaderboardEntries.length} entries created`);
  }
}

================
File: src/seeders/main.ts
================
import { CommandFactory } from 'nest-commander';
import { SeedersModule } from './seeders.module';

async function bootstrap() {
  try {
    await CommandFactory.run(SeedersModule, ['log', 'error', 'warn']);
  } catch (error) {
    console.error('Failed to run seed command:', error);
    process.exit(1);
  }
}

bootstrap();

================
File: src/seeders/seed.command.ts
================
import { Command, CommandRunner } from 'nest-commander';
import { SeederService } from './seeder.service';

@Command({
  name: 'seed',
  description: 'Seed the database with initial data',
  options: { isDefault: true },
})
export class SeedCommand extends CommandRunner {
  constructor(private readonly seederService: SeederService) {
    super();
  }

  async run(): Promise<void> {
    console.log('Starting database seeding process...');
    try {
      await this.seederService.seed();
      console.log('Database seeding completed successfully!');
    } catch (error) {
      console.error('Error during seeding:', error);
      process.exit(1);
    }
  }
}

================
File: src/seeders/seeder.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from '../user/entities/user.entity';
import { Tournament, TournamentSchema } from '../tournament/entities/tournament.entity';
import { Bounty, BountySchema } from '../bounty/entities/bounty.entity';
import { BountyWinner, BountyWinnerSchema } from '../bounty/entities/bounty-winner.entity';
import { Leaderboard, LeaderboardSchema } from '../tournament/entities/leaderboard.entity';
import { UserPerk, UserPerkSchema } from '../perks/entities/user-perk.entity';
import { SeederService } from './seeder.service';
import { UserSeeder } from './user.seeder';
import { TournamentSeeder } from './tournament.seeder';
import { BountySeeder } from './bounty.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { UserPerkSeeder } from './user-perk.seeder';
import { UserModule } from '../user/user.module';
import { TournamentModule } from '../tournament/tournament.module';
import { BountyModule } from '../bounty/bounty.module';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Tournament.name, schema: TournamentSchema },
      { name: Bounty.name, schema: BountySchema },
      { name: BountyWinner.name, schema: BountyWinnerSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: UserPerk.name, schema: UserPerkSchema },
    ]),
    UserModule,
    TournamentModule,
    BountyModule,
  ],
  providers: [
    SeederService, 
    UserSeeder, 
    TournamentSeeder, 
    BountySeeder, 
    LeaderboardSeeder,
    UserPerkSeeder
  ],
  exports: [SeederService],
})
export class SeederModule {}

================
File: src/seeders/seeder.service.ts
================
import { Injectable } from '@nestjs/common';
import { UserSeeder } from './user.seeder';
import { TournamentSeeder } from './tournament.seeder';
import { BountySeeder } from './bounty.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { UserPerkSeeder } from './user-perk.seeder';

@Injectable()
export class SeederService {
  constructor(
    private readonly userSeeder: UserSeeder,
    private readonly tournamentSeeder: TournamentSeeder,
    private readonly bountySeeder: BountySeeder,
    private readonly leaderboardSeeder: LeaderboardSeeder,
    private readonly userPerkSeeder: UserPerkSeeder,
  ) {}

  async seed() {
    try {
      console.log('Seeding users...');
      await this.userSeeder.seed();
      console.log('Users seeded successfully!');
      
      console.log('Seeding tournaments...');
      await this.tournamentSeeder.seed();
      console.log('Tournaments seeded successfully!');
      
      console.log('Seeding bounties...');
      await this.bountySeeder.seed();
      console.log('Bounties seeded successfully!');
      
      console.log('Seeding leaderboards...');
      await this.leaderboardSeeder.seed();
      console.log('Leaderboards seeded successfully!');
      
      console.log('Seeding user perks...');
      await this.userPerkSeeder.seed();
      console.log('User perks seeded successfully!');
    } catch (error) {
      console.error('Error during database seeding:', error);
      throw error;
    }
  }
}

================
File: src/seeders/tournament.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Tournament } from '../tournament/entities/tournament.entity';

@Injectable()
export class TournamentSeeder {
  constructor(
    @InjectModel(Tournament.name) private tournamentModel: Model<Tournament>,
  ) {}

  async seed() {
    const tournaments = [
      {
        name: 'Weekly Fortnite Tournament',
        description: 'Join our weekly Fortnite tournament for a chance to win amazing prizes!',
        startDate: new Date('2024-04-15T10:00:00Z'),
        endDate: new Date('2024-04-15T18:00:00Z'),
        totalPrizeMoney: 1000,
        winnerPrizeMoney: 500,
        prizePool: 1000,
        entryFee: 10,
        maxParticipants: 100,
        game: 'Fortnite',
        platform: 'PC',
        active: true,
      },
      {
        name: 'Monthly Call of Duty Championship',
        description: 'Monthly Call of Duty tournament with cash prizes and exclusive rewards',
        startDate: new Date('2024-04-20T12:00:00Z'),
        endDate: new Date('2024-04-21T20:00:00Z'),
        totalPrizeMoney: 5000,
        winnerPrizeMoney: 2500,
        prizePool: 5000,
        entryFee: 25,
        maxParticipants: 200,
        game: 'Call of Duty: Warzone',
        platform: 'Cross-Platform',
        active: true,
      },
      {
        name: 'Valorant Community Cup',
        description: 'Community-driven Valorant tournament for all skill levels',
        startDate: new Date('2024-04-25T14:00:00Z'),
        endDate: new Date('2024-04-25T22:00:00Z'),
        totalPrizeMoney: 2000,
        winnerPrizeMoney: 1000,
        prizePool: 2000,
        entryFee: 15,
        maxParticipants: 128,
        game: 'Valorant',
        platform: 'PC',
        active: false,
      },
    ];

    // Clear existing tournaments
    await this.tournamentModel.deleteMany({});
    
    // Insert new tournaments
    await this.tournamentModel.insertMany(tournaments);
    
    console.log('Tournament seeding completed');
  }
}

================
File: src/seeders/user-perk.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserPerk } from '../perks/entities/user-perk.entity';
import { User } from '../user/entities/user.entity';
import { PERKS } from '../perks/data/perks';

@Injectable()
export class UserPerkSeeder {
  constructor(
    @InjectModel(UserPerk.name) private userPerkModel: Model<UserPerk>,
    @InjectModel(User.name) private userModel: Model<User>,
  ) {}

  async seed() {
    // Get all users
    const users = await this.userModel.find().exec();
    
    // Clear existing user perks
    await this.userPerkModel.deleteMany({});
    
    const userPerks = [];
    
    // For each user, assign random perks
    for (const user of users) {
      // Select random perks for this user (between 1 and 3 different perks)
      const numberOfPerks = Math.floor(Math.random() * 3) + 1;
      const shuffledPerks = [...PERKS].sort(() => 0.5 - Math.random());
      const perksForUser = shuffledPerks.slice(0, numberOfPerks);
      
      for (const perk of perksForUser) {
        // Give random count of each perk (between 1 and 5)
        const count = Math.floor(Math.random() * 5) + 1;
        
        userPerks.push({
          userId: user._id,
          perkKey: perk.key,
          perkName: perk.name,
          count,
          used: false,
        });
      }
    }
    
    // Insert all user perks
    if (userPerks.length > 0) {
      await this.userPerkModel.insertMany(userPerks);
    }
    
    console.log(`User perk seeding completed: ${userPerks.length} perks assigned to users`);
  }
}

================
File: src/seeders/user.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from '../user/entities/user.entity';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UserSeeder {
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
  ) {}

  async seed() {
    const predefinedPassword = 'password123'; // Common password for all seeded users
    const hashedPassword = await bcrypt.hash(predefinedPassword, 10);

    const users = [
      {
        firstName: 'John',
        lastName: 'Doe',
        username: 'johndoe',
        email: 'john@example.com',
        password: hashedPassword,
        phoneNumber: '08012345678',
        instagramHandle: 'johndoe',
      },
      {
        firstName: 'Jane',
        lastName: 'Smith',
        username: 'janesmith',
        email: 'jane@example.com',
        password: hashedPassword,
        phoneNumber: '08023456789',
        instagramHandle: 'janesmith',
      },
      {
        firstName: 'Mike',
        lastName: 'Johnson',
        username: 'mikejohnson',
        email: 'mike@example.com',
        password: hashedPassword,
        phoneNumber: '08034567890',
        instagramHandle: 'mikejohnson',
      },
      {
        firstName: 'Sarah',
        lastName: 'Williams',
        username: 'sarahwilliams',
        email: 'sarah@example.com',
        password: hashedPassword,
        phoneNumber: '08045678901',
        instagramHandle: 'sarahwilliams',
      },
      {
        firstName: 'David',
        lastName: 'Brown',
        username: 'davidbrown',
        email: 'david@example.com',
        password: hashedPassword,
        phoneNumber: '08056789012',
        instagramHandle: 'davidbrown',
      },
    ];

    // Clear existing users
    await this.userModel.deleteMany({});
    
    // Insert new users
    await this.userModel.insertMany(users);
    
    console.log('User seeding completed');
  }
}

================
File: src/tournament/dto/create-tournament.dto.ts
================
import { IsBoolean, IsDate, IsNotEmpty, IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class CreateTournamentDto {
  @IsNotEmpty()
  @IsString()
  readonly name: string;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  readonly startDate: Date;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  readonly endDate: Date;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  readonly winnerPrizeMoney: number;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  readonly totalPrizeMoney: number;

  @IsOptional()
  @IsString()
  readonly description?: string;

  @IsOptional()
  @IsBoolean()
  readonly active?: boolean;
}

================
File: src/tournament/dto/get-leaderboard.dto.ts
================
import { IsNotEmpty, IsNumber, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class GetLeaderboardDto {
  @IsNotEmpty()
  @IsString()
  readonly tournamentId: string;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Type(() => Number)
  readonly limit?: number;
}

================
File: src/tournament/dto/record-score.dto.ts
================
import { IsNotEmpty, IsNumber, IsString, Min } from 'class-validator';

export class RecordScoreDto {
  @IsNotEmpty()
  @IsString()
  readonly tournamentId: string;

  @IsNotEmpty()
  @IsString()
  readonly userId: string;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  readonly score: number;
}

================
File: src/tournament/dto/update-tournament.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreateTournamentDto } from './create-tournament.dto';

export class UpdateTournamentDto extends PartialType(CreateTournamentDto) {}

================
File: src/tournament/entities/leaderboard.entity.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { Tournament } from './tournament.entity';

export type LeaderboardDocument = Leaderboard & Document;

@Schema({ timestamps: true })
export class Leaderboard {
  @Prop({ required: true })
  username: string;

  @Prop({ required: true })
  firstName: string;

  @Prop({ required: true })
  lastName: string;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'Tournament', required: true })
  tournamentId: Tournament;

  @Prop({ required: true })
  tournamentName: string;

  @Prop({ required: true })
  score: number;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: string;
}

export const LeaderboardSchema = SchemaFactory.createForClass(Leaderboard);

================
File: src/tournament/entities/tournament.entity.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type TournamentDocument = Tournament & Document;

@Schema({ timestamps: true })
export class Tournament {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  startDate: Date;

  @Prop({ required: true })
  endDate: Date;

  @Prop({ required: true })
  winnerPrizeMoney: number;

  @Prop({ required: true })
  totalPrizeMoney: number;

  @Prop()
  description: string;

  @Prop({ default: true })
  active: boolean;
}

export const TournamentSchema = SchemaFactory.createForClass(Tournament);

================
File: src/tournament/tournament.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Put,
  Query,
  UseGuards,
} from '@nestjs/common';
import { TournamentService } from './tournament.service';
import { CreateTournamentDto } from './dto/create-tournament.dto';
import { UpdateTournamentDto } from './dto/update-tournament.dto';
import { RecordScoreDto } from './dto/record-score.dto';
import { GetLeaderboardDto } from './dto/get-leaderboard.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('tournaments')
export class TournamentController {
  constructor(private readonly tournamentService: TournamentService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  create(@Body() createTournamentDto: CreateTournamentDto) {
    return this.tournamentService.create(createTournamentDto);
  }

  @Get()
  findAll() {
    return this.tournamentService.findAll();
  }

  @Get('active')
  findActive() {
    return this.tournamentService.findActiveTournaments();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.tournamentService.findOne(id);
  }

  @UseGuards(JwtAuthGuard)
  @Put(':id')
  update(
    @Param('id') id: string,
    @Body() updateTournamentDto: UpdateTournamentDto,
  ) {
    return this.tournamentService.update(id, updateTournamentDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.tournamentService.remove(id);
  }

  // @UseGuards(JwtAuthGuard)
  @Post('record-score')
  recordScore(@Body() recordScoreDto: RecordScoreDto) {
    return this.tournamentService.recordScore(recordScoreDto);
  }

  @Get('leaderboard/:tournamentId')
  getLeaderboard(
    @Param('tournamentId') tournamentId: string,
    @Query('limit') limit?: number,
  ) {
    const getLeaderboardDto: GetLeaderboardDto = {
      tournamentId,
      limit: limit ? parseInt(limit.toString(), 10) : undefined,
    };
    return this.tournamentService.getLeaderboard(getLeaderboardDto);
  }
}

================
File: src/tournament/tournament.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { TournamentService } from './tournament.service';
import { TournamentController } from './tournament.controller';
import { Tournament, TournamentSchema } from './entities/tournament.entity';
import { Leaderboard, LeaderboardSchema } from './entities/leaderboard.entity';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Tournament.name, schema: TournamentSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
    ]),
    UserModule,
  ],
  controllers: [TournamentController],
  providers: [TournamentService],
  exports: [TournamentService],
})
export class TournamentModule {}

================
File: src/tournament/tournament.service.ts
================
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateTournamentDto } from './dto/create-tournament.dto';
import { UpdateTournamentDto } from './dto/update-tournament.dto';
import { Tournament, TournamentDocument } from './entities/tournament.entity';
import { Leaderboard, LeaderboardDocument } from './entities/leaderboard.entity';
import { RecordScoreDto } from './dto/record-score.dto';
import { GetLeaderboardDto } from './dto/get-leaderboard.dto';
import { UserService } from '../user/user.service';

@Injectable()
export class TournamentService {
  constructor(
    @InjectModel(Tournament.name) private tournamentModel: Model<TournamentDocument>,
    @InjectModel(Leaderboard.name) private leaderboardModel: Model<LeaderboardDocument>,
    private readonly userService: UserService,
  ) {}

  async create(createTournamentDto: CreateTournamentDto): Promise<Tournament> {
    const createdTournament = new this.tournamentModel(createTournamentDto);
    return createdTournament.save();
  }

  async findAll(): Promise<Tournament[]> {
    return this.tournamentModel.find().exec();
  }

  async findOne(id: string): Promise<Tournament> {
    const tournament = await this.tournamentModel.findById(id).exec();
    if (!tournament) {
      throw new NotFoundException(`Tournament with ID ${id} not found`);
    }
    return tournament;
  }

  async update(id: string, updateTournamentDto: UpdateTournamentDto): Promise<Tournament> {
    const tournament = await this.tournamentModel
      .findByIdAndUpdate(id, updateTournamentDto, { new: true })
      .exec();
    
    if (!tournament) {
      throw new NotFoundException(`Tournament with ID ${id} not found`);
    }
    
    return tournament;
  }

  async remove(id: string): Promise<Tournament> {
    const tournament = await this.tournamentModel.findByIdAndDelete(id).exec();
    if (!tournament) {
      throw new NotFoundException(`Tournament with ID ${id} not found`);
    }
    return tournament;
  }

  async recordScore(recordScoreDto: RecordScoreDto): Promise<Leaderboard> {
    const { tournamentId, userId, score } = recordScoreDto;
    
    // Check if tournament exists
    const tournament = await this.tournamentModel.findById(tournamentId).exec();
    if (!tournament) {
      throw new NotFoundException(`Tournament with ID ${tournamentId} not found`);
    }
    
    // Check if user exists
    const user = await this.userService.findOne(userId);
    
    // Check if user already has a score for this tournament
    const existingRecord = await this.leaderboardModel.findOne({
      tournamentId,
      userId,
    }).exec();
    
    if (existingRecord) {
      // If new score is higher, update it
      if (score > existingRecord.score) {
        existingRecord.score = score;
        return existingRecord.save();
      }
      // If not higher, return existing record without updating
      return existingRecord;
    }
    
    // Create a new leaderboard entry
    const leaderboardEntry = new this.leaderboardModel({
      tournamentId,
      tournamentName: tournament.name,
      userId,
      username: user.username,
      firstName: user.firstName,
      lastName: user.lastName,
      score,
    });
    
    return leaderboardEntry.save();
  }

  async getLeaderboard(getLeaderboardDto: GetLeaderboardDto): Promise<{
    tournament: Tournament;
    leaderboard: Leaderboard[];
  }> {
    const { tournamentId, limit } = getLeaderboardDto;

    // Check if tournament exists
    const tournament = await this.tournamentModel.findById(tournamentId).exec();
    if (!tournament) {
      throw new NotFoundException(`Tournament with ID ${tournamentId} not found`);
    }
    
    // Get leaderboard entries, sorted by score in descending order
    let leaderboardQuery = this.leaderboardModel
      .find({ tournamentId })
      .sort({ score: -1 });
    
    // Apply limit if provided
    if (limit) {
      leaderboardQuery = leaderboardQuery.limit(limit);
    }
    
    const leaderboard = await leaderboardQuery.exec();
    
    return {
      tournament,
      leaderboard,
    };
  }

  async findActiveTournaments(): Promise<{ hasActive: boolean; tournament?: Tournament }> {
    const activeTournaments = await this.tournamentModel.find({ active: true }).exec();
    if (activeTournaments.length === 0) {
      return { hasActive: false };
    }
    return { hasActive: true, tournament: activeTournaments[0] };
  }
}

================
File: src/user/dto/create-user.dto.ts
================
import { IsEmail, IsNotEmpty, IsOptional, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsNotEmpty()
  @IsString()
  readonly firstName: string;

  @IsNotEmpty()
  @IsString()
  readonly lastName: string;

  @IsNotEmpty()
  @IsString()
  readonly username: string;

  @IsNotEmpty()
  @IsEmail()
  readonly email: string;

  @IsOptional()
  @IsString()
  readonly phoneNumber?: string;

  @IsOptional()
  @IsString()
  readonly instagramHandle?: string;

  @IsNotEmpty()
  @IsString()
  @MinLength(6)
  readonly password: string;
}

================
File: src/user/dto/update-user.dto.ts
================
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';
import { IsEmail, IsOptional, IsString } from 'class-validator';

export class UpdateUserDto extends PartialType(CreateUserDto) {
  @IsOptional()
  @IsString()
  readonly firstName?: string;

  @IsOptional()
  @IsString()
  readonly lastName?: string;

  @IsOptional()
  @IsString()
  readonly username?: string;

  @IsOptional()
  @IsEmail()
  readonly email?: string;

  @IsOptional()
  @IsString()
  readonly phoneNumber?: string;

  @IsOptional()
  @IsString()
  readonly instagramHandle?: string;
}

================
File: src/user/entities/user.entity.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import * as bcrypt from 'bcrypt';

export type UserDocument = User & Document;

@Schema({
  timestamps: true,
  toJSON: {
    transform: (_, ret) => {
      delete ret.password;
      delete ret.__v;
      return ret;
    },
  },
})
export class User {
  @Prop({ required: true })
  firstName: string;

  @Prop({ required: true })
  lastName: string;

  @Prop({ required: true, unique: true })
  username: string;

  @Prop({ required: true, unique: true })
  email: string;

  @Prop()
  phoneNumber?: string;

  @Prop()
  instagramHandle?: string;

  @Prop({ required: true })
  password: string;

  @Prop({ default: false })
  isVerified: boolean;

  @Prop()
  passwordResetToken?: string;

  @Prop()
  passwordResetExpires?: Date;

  validatePassword: (password: string) => Promise<boolean>;
}

export const UserSchema = SchemaFactory.createForClass(User);

UserSchema.methods.validatePassword = async function (password: string): Promise<boolean> {
  return bcrypt.compare(password, this.password);
};

UserSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    return next();
  }

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

================
File: src/user/user.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Put,
  UseGuards,
} from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  findAll() {
    return this.userService.findAll();
  }

  @UseGuards(JwtAuthGuard)
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findOne(id);
  }

  @UseGuards(JwtAuthGuard)
  @Put(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(id, updateUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }
}

================
File: src/user/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UserService } from './user.service';
import { UserController } from './user.controller';
import { User, UserSchema } from './entities/user.entity';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}

================
File: src/user/user.service.ts
================
import {
  BadRequestException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { User, UserDocument } from './entities/user.entity';
import * as crypto from 'crypto';

@Injectable()
export class UserService {
  constructor(@InjectModel(User.name) private userModel: Model<UserDocument>) {}

  async create(createUserDto: CreateUserDto): Promise<User> {
    // Check if username or email already exists
    const userExists = await this.userModel.findOne({
      $or: [
        { email: createUserDto.email },
        { username: createUserDto.username },
      ],
    });

    if (userExists) {
      throw new BadRequestException(
        'User with this email or username already exists',
      );
    }

    const createdUser = new this.userModel(createUserDto);
    return createdUser.save();
  }

  async findAll(): Promise<User[]> {
    return this.userModel.find().exec();
  }

  async findOne(id: string): Promise<User> {
    const user = await this.userModel.findById(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async findByUsername(username: string): Promise<User> {
    const user = await this.userModel.findOne({ username }).exec();
    if (!user) {
      throw new NotFoundException(`User with username ${username} not found`);
    }
    return user;
  }

  async findByEmail(email: string): Promise<User> {
    const user = await this.userModel.findOne({ email }).exec();
    if (!user) {
      throw new NotFoundException(`User with email ${email} not found`);
    }
    return user;
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {
    // Check if username or email already exists if trying to update those fields
    if (updateUserDto.username || updateUserDto.email) {
      const existingUser = await this.userModel.findOne({
        $and: [
          { _id: { $ne: id } },
          {
            $or: [
              updateUserDto.email
                ? { email: updateUserDto.email }
                : { email: null },
              updateUserDto.username
                ? { username: updateUserDto.username }
                : { username: null },
            ],
          },
        ],
      });

      if (existingUser) {
        throw new BadRequestException(
          'User with this email or username already exists',
        );
      }
    }

    const updatedUser = await this.userModel
      .findByIdAndUpdate(id, updateUserDto, { new: true })
      .exec();

    if (!updatedUser) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }

    return updatedUser;
  }

  async remove(id: string): Promise<User> {
    const deletedUser = await this.userModel.findByIdAndDelete(id).exec();
    if (!deletedUser) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return deletedUser;
  }

  async createPasswordResetToken(email: string): Promise<string> {
    const user = await this.userModel.findOne({ email }).exec();
    if (!user) {
      throw new NotFoundException(`User with email ${email} not found`);
    }

    const resetToken = crypto.randomBytes(32).toString('hex');

    user.passwordResetToken = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');
    user.passwordResetExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await user.save();

    return resetToken;
  }

  async resetPassword(token: string, newPassword: string): Promise<void> {
    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

    const user = await this.userModel.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() },
    });

    if (!user) {
      throw new BadRequestException('Token is invalid or has expired');
    }

    user.password = newPassword;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;

    await user.save();
  }
}

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import * as express from 'express';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Configure Express to handle raw body for webhooks
  app.use(express.json({
    verify: (req: any, res, buf) => {
      // Make raw body available for webhook signature verification
      req.rawBody = buf;
    }
  }));
  
  // Global prefix
  app.setGlobalPrefix('api');
  
  // Global pipes
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
    }),
  );
  
  // CORS with credentials support
  app.enableCors({
    origin: ['http://localhost:5500', 'http://127.0.0.1:5500', "https://rabbitholegames.africa/"],
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    credentials: true,
  });
  
  await app.listen(process.env.PORT || 3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: .eslintignore
================
*

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin', 'prettier'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prettier/prettier': 'warn',
    'indent': 'off',
    '@typescript-eslint/indent': 'off',
    'quotes': 'off',
    'semi': 'off',
    'comma-dangle': 'off',
    'max-len': ['warn', { 'code': 120 }],
    'no-trailing-spaces': 'warn',
    'no-multiple-empty-lines': 'warn',
    'object-curly-spacing': 'off',
    'eol-last': 'off',
    'linebreak-style': 'off',
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

================
File: .prettierignore
================
node_modules
dist
coverage
.env
.env.*
package-lock.json
*.md

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "es5",
  "printWidth": 120,
  "semi": true,
  "endOfLine": "auto",
  "arrowParens": "avoid",
  "bracketSpacing": true,
  "tabWidth": 2
}

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true,
    "builder": "swc",
    "typeCheck": true,
    "plugins": []
  }
}

================
File: package.json
================
{
  "name": "naija-sniper",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "lint:warn": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix --quiet --max-warnings=100",
    "lint:check": "eslint \"{src,apps,libs,test}/**/*.ts\" --quiet --max-warnings=100",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "seed": "ts-node src/seeders/main.ts"
  },
  "dependencies": {
    "@nestjs/axios": "^4.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/mongoose": "^11.0.3",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.0.0",
    "axios": "^1.8.4",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "express": "^5.1.0",
    "mongoose": "^8.13.2",
    "nest-commander": "^3.17.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@swc/cli": "^0.5.2",
    "@swc/core": "^1.11.20",
    "@types/bcrypt": "^5.0.2",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.6",
    "jest": "^29.5.0",
    "prettier": "^3.5.3",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: README.md
================
# Naija Sniper Backend

This is the backend service for the Naija Sniper mobile game, built with NestJS and MongoDB.

## Features

- **User Management**: Registration, authentication, profile management
- **Tournament System**: Create tournaments, record scores, view leaderboards
- **Bounty System**: Create bounties, record winners

## Prerequisites

- Node.js (v16 or later)
- MongoDB (local or Atlas)

## Installation

```bash
# Install dependencies
npm install
```

## Configuration

Create a `.env` file in the root directory and add the following variables:

```
MONGODB_URI=mongodb://localhost:27017/naija-sniper
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=7d
```

## Running the app

```bash
# Development
npm run start:dev

# Production mode
npm run build
npm run start:prod
```

## API Endpoints

### Authentication

- `POST /api/auth/register` - Register a new user
- `POST /api/auth/login` - Login
- `POST /api/auth/forgot-password` - Request password reset
- `POST /api/auth/reset-password` - Reset password

### Users

- `GET /api/users` - Get all users
- `GET /api/users/:id` - Get user by ID
- `PUT /api/users/:id` - Update user
- `DELETE /api/users/:id` - Delete user

### Tournaments

- `GET /api/tournaments` - Get all tournaments
- `GET /api/tournaments/active` - Get active tournaments
- `GET /api/tournaments/:id` - Get tournament by ID
- `POST /api/tournaments` - Create tournament
- `PUT /api/tournaments/:id` - Update tournament
- `DELETE /api/tournaments/:id` - Delete tournament
- `POST /api/tournaments/record-score` - Record a score
- `GET /api/tournaments/leaderboard/:tournamentId` - Get tournament leaderboard

### Bounties

- `GET /api/bounties` - Get all bounties
- `GET /api/bounties/active` - Get active bounties
- `GET /api/bounties/:id` - Get bounty by ID
- `POST /api/bounties` - Create bounty
- `PUT /api/bounties/:id` - Update bounty
- `DELETE /api/bounties/:id` - Delete bounty
- `POST /api/bounties/winners` - Add a bounty winner
- `GET /api/bounties/winners/:bountyId` - Get winners for a bounty
- `DELETE /api/bounties/winners/:id` - Remove a bounty winner

## License

This project is licensed under the MIT License.

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
